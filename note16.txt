리덕스(Redux)?
리액트 상태 관리 라이브러리!

global state의 관리가 어렵다!
-> 하나의 store에 저장해 놓음으로써 global state의 관리가 쉬워졌다!

Flux를 먼저 알아야한다. 왜냐하면 Redux는 Flux구조의 구현체라고 볼 수 있기 때문이다.
그렇다면 Flux를 알아보자.

Flux아키텍쳐는 MVC아키텍처의 한계를 보완하고자 고안된 구조이다.
무엇이 한계였나?
프로젝트 규모가 커질수록 구조가 매우 복잡해진다!!

대표적인 문제!
이 같은 문제의 대표적인 사례가 바로 페이스북의 안 읽은 글 갯수(unread count) 표시이다. 
사용자가 읽지 않았던 글을 읽으면 읽지 않은 글 갯수에서 읽은 글 수만큼 빼면 되는 일견 단순해보이는 기능인데도,
페이스북 서비스에서 이를 MVC로 구현하기는 어려웠다고 한다. 
어떤 글을 '읽음' 상태로 두면, 먼저 글을 다루는 thread 모델을 업데이트 해야하고 동시에 unread ​count 모델도 업데이트 해야한다. 
대규모 MVC 애플리케이션에서 이 같은 의존성과 순차적 업데이트는 종종 데이터의 흐름을 꼬이게 하여 예기치 못한 결과를 불러일으킨다.

Flux는 크게 dispatcher , model, view 3개로 구성된다.
가장 큰 특징은 단방향 데이터 흐름이다.
이런 단방향 데이터 흐름은 데이터 변화를 훨~씬 예측하기 쉽게 만든다.

참조 https://blog.coderifleman.com/2015/06/19/mvc-does-not-scale-use-flux-instead/
하지만 위 참조글을 보자, 재미삼아 보는거긴 하지만 내생각도 여기의 글과 같기때문.. ㅋㅋ

액션?
상태에 어떤 변화가 필요하면 액션발생! 액션은 하나의 객체로 표현된다.
아래 415쪽의 그림과같이.

액션생성함수?
액션객체를 만들어주는 함수! => 항상 액션객체를 직접 작성하기 힘드니까.

리듀서?
실제 업데이트 로직이 있는 함수

스토어?
프로젝트에는 단 하나의 스토어만 있을 수 있다.
action과 reducer를 저장하는 객체이다.

디스패치?
스토어의 내장함수로 액션객체를 파라미터로 스토어에 저장된 reducer를 실행시킨다.

구독?
subscribe또한 내장함수이다. 리스너함수를 subscribe함수의 파라미터로 넣어서 호출해주면
업데이트 될때마다 실행된다.

액션, 액션생성함수, 리듀서, 스토어, 디스패치, 구독
보면 여기까지는 잘 모르겠지만 hook에 useReducer를 보는것 같다.

16.2에서 말하는걸보면 이번 16장은 리액트와 리덕스가아닌 '리덕스' 자체만의 핵심 기능과 작동 원리를 이해해보겠다고 한다.

index.js코드를 보며 따라가봅시다.

규칙 3가지!!
1. 단일스토어. 다수의 스토어사용 가능하나 권장하지 않는다.
2. 읽기전용 상태이다. 즉, 리덕스 또한 불변성을 가지고 있다.~~
3. 순수함수이다. 
    a. 이전 상태와 액션객체를 파라미터로 받아야한다.
    b. 파라미터 외의 값에 의존하면 안된다.
    c. 이전상태를 절대 건드리지 않고 새로운 객체를 만들어 반환한다.
    d. 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환한다.