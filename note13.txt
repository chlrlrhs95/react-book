SPA?
single page application

다른주소에 다른 화면을 보여주는것을 라우팅이라고 한다.

SPA의 단점 1
 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다.
why? 페이지 로딩 시 사용자가 실제로 방문하지 않을 페이지의 스크립트도 불러오기 때문!

보완-> 코드스플리팅을 사용하면 라우트별로 파일을 나누어서 트래픽과 로딩속도를 개선할 수 있다.

단점 2
크롤링의 문제점 => 자바스크립트를 실행하지 않는 일반 크롤러에서 정보를 제대로 수집해 가지 못한다.

단점 3
자바스크립트가 실행될 때 까지 빈화면이 나타날 수 있다.
보완 -> 서버사이드 렌더링!

a태그를 사용하게되면 페이지를 전환하는 과정에서 페이지를 새로 불러오는데, 이때 상태를 모두 날려버리고 전부다 다시 처음부터 렌더링한다.

Link태그는 새로 불러오지않고 애플리케이션은 그대로 유지한 상태에서 Hitsory API를 사용하여 페이지의 주소만 변경해준다.

url 파라미터사용방법
match객체 안에는 현재 컴포넌트가 어떤 경로 규칙에 의해 보이는지에 대한 정보가 들어있따.
path, url, params 등의 값을 저장하고잇다.
라우트로 사용되는 컴포넌트에서 받아오는 match라는 객체안의 params값을 참조한다.

url 쿼리 사용방법
location객체 안에는 현재 컴포넌트의 주소에 대한 정보가 있다.
search, pathname, hash, key, state 가 있다.
search에는 ?이후의 문자열에 대한 정보가잇는데
이 문자열을 객체로 만들어 주기위해 qs라이브러리 사용한다.

Hitsory객체는 라우트로 사용된 컴포넌트에 match, location과 함께 전달되는 props중 하나이다.
뒤로가거나, 로그인 후 화면전환, 다른페이지로 이탈방지에 활용된다.

history구성
- push(path, state) 해당 path로 이동한다.
- goBack() 뒤로가기함수
- function block(prompt) { 현재페이지 이탈을방지해준다.
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }
  prompt의 정보에 따라 block, unblock을 정해준다. checkDomListners에게 이벤트 알림.

withRouter => Route로 접근된 컴포넌트가 아니더라도 location, history, match 객체에 접근할 수 있도록해준다.!

Switch!!
여러 Route중 일치하는 단 하나의 라우트만을 렌더링 시켜준다.
모든 규칙과 일치하지 않을 때 보여줄 Not Found페이지도 구현할 수 있게된다! 굳

NavLink는 Link와 비슷하다.
현재 경로와 Link에서 사용하는 경로가 일치하는 경우 특정 스타일 혹은 CSS 클래스를 적용할 수 있는 컴포넌트이다.
activeStyle props 또는 activeClassName