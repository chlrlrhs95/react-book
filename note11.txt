컴포넌트의 리렌더링 invoke상황
1. 자신이 전달받은 props가 변경될 때
2. 자신의 state가 바뀔 때
3. 부모 컴포넌트가 리렌더링 될 때
4. forceUpdate함수가 실행될 때

React.memo?
리렌더링을 방지하기위해 라이프사이클 메소드의 shouldComponetUpdate(scu)를 사용하였었다.
하지만 함수형 컴포넌트는 라이프사이클 메소드를 사용할 수 없다.
이를 대체하는 것이 React.memo!!!

렌더링 시 그 결과를 메모이징한다.
그리고 다음 렌더링에서 props가 같다면, 메모이징 된 내용을 재사용 한다.

기본적으로 React.memo()는 얕은비교를한다. 가르키는 주소값이 같은지!
비교방식을 수정하려면 비교함수를 두번째 매개변수로 넘겨주면 된다.

실수하지 않기 위한 활용 예시!
참조(https://ui.toast.com/weekly-pick/ko_20190731)
의 4번 보자.

onRemove와 onToggle의 경우 todos가 변할 때마다
함수가 새로 만들어진다. 이렇게 함수가 새로 바뀌게되면 위에서 본것과 같이
memo를 하더라도 계속 리렌더링 하게된다.
이것을 방지해보자.

1. useState 함수형 업데이트
useCallback에서 새로운 함수를 만들어야 하는 이유?
두번째 파라미터에 있는 state를 참조하고있다. 즉, 참조 state가 바뀌면 현재 함수에서는 이전의 state를 참조하고 있어서
바뀐 state를 참조하지 않고이씩 때문에 함수를 다시 선언해주어야한다.
하지만 함수형 업데이트를 하게 된다면, 외부에서 값을 넘겨주기 때문에 참조할 필요가 없어진다.
로 이해했는데 맞나요?

2. useReducer 사용
원래는 두번째 파라미터에 초기상태를 넣어주어야한다.
위 예시처럼 하면, 컴포넌트가 맨처음 렌더링 될때만 초기화 함수가 호출 된다.
성능상 비슷, 취향따라 사용하면 된다. 이거 사용하면, 로직 분리관리의 장점이 있음.

불변성의 중요성!
위 내용 한번 읽어봅시다!

react-virtualized를 사용한 최적화.
스크롤되기 전에 보이지 않는 컴포넌트는 렌더링하지 않고 크기만 차지하게끔 할 수 있다!!
rowRenderer => index, key, style값을 객체타입으로 받아와서 사용한다.
성능이 엄청 향상된다.