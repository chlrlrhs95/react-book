비동기작업관리!

리액트 어플리케이션에서 API서버를 연동할 때에도 API요청에대한 상태도 잘 관리해야한다.
로딩중, 요청성공, 요청실패 등 에 대한 상태관리 필요하다.

이렇게 비동기작업관리를 할때 미들웨러릀 ㅏ용하면 효율적이고 편하게 상태관리를 할 수 있다고한다.
어떻게 하는지 한번 알아보자.

476쪽 그림 18-3
리덕스 미들웨어란??
액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행합니다.
미들웨어는 액션과 리듀서사이의 중간자라고 볼 수 있다.

콘솔에 기록하거나, 전달받은 액션정보를 기반으로 액션을 아예 취소하거나, 다른 종류의 액션을 추가로 디스패치할 수 도 있다.

479쪽
next?
store의 dispatch와 비슷한 역할을 한다. 하지만 큰 차이점은 next(action)을 호출하면 그다음 미들웨어에게 액션을 넘겨준다는 것. 그리고 '없다면' 리듀서에게 액션을 넘겨준다.
console을 찍어보니 createStore함수 내부의 dispatch함수이다.

ㄴ> 추가내용!, 뒤에 미들웨어가 더 있다면 해당 미들웨어의 함수이다(redux-thunk에서는 createThunkMiddleware ). 만약 뒤에 더이상 미들웨어가 없다면 
dispatch를 실행한다.

store.dispatch함수를 실행하면 recursive하게 첫번째 미들웨어로 돌아간다.
ㄴ> 재귀함수처럼 행동한다.

비동기작업을 처리할 때 미들웨어를 사용하면 더욱 효율적으로 사용할 수 있다.

redux-thunk : 함수형태의 액션을 디스패치할 수 있게 해준다.
redux-saga : 특정 액션이 디스패치되었을 때 정해진 로직에 따라 다른 액션을 디스패치 시키는 규칙을 작성하여 비동기 작업을 처리 할수 있다.

redux-thunk?
Thunk는 특정 작업을 나중에 할 수 있도록 미루기위해 함수 형태로 감싼것을 의미한다.

485쪽까지 보면서,,
액션객체가 아닌 함수를 반환시켜 비동기적으로 값을 변경시킨다.

내생각. 이렇게하면 각 액션객체별로 필요한 async함수(thunk함수)를 따로 만들어 줘야한다.
그럴바에는 비동기식으로만드는 함수를 따로 만들어서 함수로 랩핑해주어 나중에 실행되게 해주는 방식으로 사용하는게 이득아닌가?
const async = (func) =>
    function () {
      setTimeout(() => {
        func();
      }, 1000);
    };
    이런식으로

async(onIncrease), async(onDecrease)
내가 이미 동기적으로 만들어논함수를 비동기함수로 래핑해주는 것이다.

웹요청 비동기 작업처리하기

495쪽의 리팩토링에서 내가 위에서 말한생각을 대변해준다.

495쪽까지 프로젝트를 잘 따라하고나니 의문이 들었다.
module/sample.js에서 createRequestThunk를 통해 나온 getPost값은 함수이다.
getPost = (params) => async (dispatch) => {
    ...
} 위와 같은 타입의 함수를 가진다.

그런데 dispatch(getPost(id))를 하면 getPost(id)는 
async (dispatch) => {
    ...
} 의 함수를 반환한다.
그이후에 실행하는 구문이 없음에도 위 프로젝트는 함수가 잘 실행되어서 처리가 된다.
함수형태로 넘겨주면 이후에 실행하게 해준다지만 어디서 실행되는걸까?

async (dispatch) => {
    ...
}의 함수가 잘 실행이 되는상황이 궁금해졌다.

휴! 찾았따. 
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') { ============================이부분을 잘 보자.
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

미들웨어에 있는 Redux-thunk에서 next(action)의 처리부분에서 이 함수 실행처리가 자동으로 일어난다.
위의 코드는 next를 로그 찍어본 결과이다.
보면 action의 타입이 함수일 경우 action을 실행시키는 구문이 보일 것이다.

여기까지 하고 의문점
내가 만든 그냥 함수를 async함수로 감싸서 실행하게 되면 비동기 작업을 처리할 수 있다.
하지만 redux-thunk는 괜히 함수를 보내서 함수를 한번 실행하고, 그이후 다시 함수내부 액션을 실행한다.
굳이? 이점이 뭘까.

실제로 한번 redux-thnuk를 없애고 짜봤다. 내부적으로 이점이 있을 수 있겠지만, 잘 모르겠다.
그냥 굳이 쓸 이유가 없어보인다.


redux-saga를 통한 비동기 작업관리
언제 유용한가? 502쪽 읽어보자.
대부분의경우에는 redux-thunk로 처리가능하다.

제너레이터 함수?
함수에서 값을 순차적으로 반환할 수 있다. 심지어 흐름을 도중에 멈추고 다시 진행도 가능하다.

제너레이터함수
function* generatorFunction() {

}
redux-saga는 제너레이터 함수 문법을 기준으로 비동기 작업을 관리해준다.